#pragma once
struct Node
{
    double g;
    double h;
    double f;

    POINT pos;
    POINT parent;
};
class PriorityQueue
{
private:
    vector<Node> arr;
public:
    PriorityQueue();
    ~PriorityQueue();
    void Push(Node node);
    Node Pop();
    int GetCount();
    
};

/*
스페이스바를 누르면 플레이어가 playerRail에서 나갈 수 있게 되고 이때
에너미존으로 들어가지 못하게 하는 방법 2가지
enemyZone으로 만든 폴리곤 안쪽 충돌체크해서 못들어가게,
점이 홀수인지 체크해서 못들어가게

플레이어가 tempRail로 그린다.
tempRail을 그리는 원리는 실시간으로 출발좌표 ~방향전환한 점 ~ 플레이어 위치 점들을 기억해서
LineTO로 그림
playerRail에서 스페이스바를 누르고 enemyZone으로 나가고
방향을 전환할때마다 점을 스택에다 저장한다. 만약 스페이스바를 땔 경우
스택을 따라서 다시 돌아간다. 다 돌아가면 tempRail 초기화
만약 돌아다니다 PlayerRail 에 다시 도달하면 enemyZone이랑 PlayerRail을 다시 그려야 하는데
이 때 출발점 - 도착점 사이의 점들이 소실된다.
여기서 두가지 레일이 만들어 지는데 소실점들과 추가점들이 이어진 A레일(소실레일)과
원래 레일에서 소실점을 뺀 레일 + 추가점인 B레일(빅레일)이 생긴다.


소실레일의 공식은 원래 레일에서 출발점과 도착점 사이의 레일 점을 추출한다
출발점 - 사이점 - 도착점 식으로 추출하고 여기서 새로 추가한 점들을 추가한다.
양방향 원형리스트로 구현해야 편할듯

빅레일의 공식은 원래 레일에서 출발점에서 도착점 사이 레일을 삭제한 후 그 사이에 새로 추가한
점들을 추가한다
삭제된 레일 - 출발점 - 새로 그린 점 - 도착점 - 삭제된 레일 식으로 이어붙임


굳이소실점이라 안하고 반토막 냈을때을 생각하면
원형 링크드 리스트 레일에서 플레이어가 움직일 때 마다 마지막으로 밟은 점을 기억해 놓고
플레이어가 스페이스바로 나갈 때 출발점을 기준으로 좌우점(A,B)을 뽑고
도착점에서 원래 지정되어있는 좌우 점(C,D)을 뽑고
그 점에 도착할때까지 A점에서 C혹은 D를 만날 때까지 +든 -든 쭉 보내서 만든 반토막레일(Q)1개
B점에서 C혹은 D를 만날때까지 방향 반대로 쭉 보내서 만든 반토막레일(W) 1개를 만든다

이제 Q레일 완성버전은
Q레일 - 출발점 - 새로 만든 레일 - 도착점
W레일도 이하 동일하다


구해야 할 건 출발점 당시의 라인 좌우 점
도착점 당시의 라인 좌우점 이다.
상하, 좌우로 반복문을 쏴서 2개의 접촉점이 나오면 이를 좌우점이라 지정함

*/